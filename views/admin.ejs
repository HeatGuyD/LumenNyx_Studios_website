// FILE: routes/admin.js
const express = require('express');

module.exports = function adminRoutes(ctx) {
  const router = express.Router();
  const { dbGet, dbAll, dbRun } = ctx.db;

  // ------------------------
  // Guards
  // ------------------------
  function requireStaff(req, res, next) {
    const u = req.session?.user;
    if (!u) return res.redirect('/login');
    if (u.role !== 'admin' && u.role !== 'staff') {
      return res.status(403).render('error', { message: 'Access denied.' });
    }
    return next();
  }

  // ------------------------
  // Helpers (schema-safe)
  // ------------------------
  async function tableExists(name) {
    try {
      const row = await dbGet(
        `SELECT name FROM sqlite_master WHERE type='table' AND name=? LIMIT 1`,
        [name]
      );
      return !!row;
    } catch (_e) {
      return false;
    }
  }

  async function safeCount(sql, params = []) {
    try {
      const row = await dbGet(sql, params);
      const v = row && (row.c ?? row.count ?? row.total);
      const n = Number(v);
      return Number.isFinite(n) ? n : 0;
    } catch (_e) {
      return 0;
    }
  }

  function firstOf(obj, keys, fallback = null) {
    for (const k of keys) {
      if (obj && Object.prototype.hasOwnProperty.call(obj, k) && obj[k] != null) return obj[k];
    }
    return fallback;
  }

  // ------------------------
  // Studio Panel (Dashboard)
  // ------------------------
  router.get('/studio-panel', requireStaff, async (req, res) => {
    try {
      const totalModels = await safeCount(`SELECT COUNT(*) AS c FROM users WHERE role='model'`);
      const pendingModels = await safeCount(
        `SELECT COUNT(*) AS c FROM users WHERE role='model' AND status='pending'`
      );
      const approvedModels = await safeCount(
        `SELECT COUNT(*) AS c FROM users WHERE role='model' AND (status='approved' OR status='active')`
      );

      const CONTACT_EMAILS = ctx.STUDIO_EMAILS;
      const MAIL_TO_STUDIO =
        (process.env.MAIL_TO_STUDIO && String(process.env.MAIL_TO_STUDIO).trim()) ||
        ctx.STUDIO_EMAILS.admin;

      return res.render('studio-panel', {
        stats: { totalModels, pendingModels, approvedModels },
        role: req.session.user?.role || 'staff',
        CONTACT_EMAILS,
        MAIL_TO_STUDIO,
      });
    } catch (err) {
      console.error('Studio panel error:', err);
      return res.status(500).render('error', { message: 'An internal error occurred.' });
    }
  });

  // ------------------------
  // Models List (renders studio-models.ejs)
  // ------------------------
  router.get('/studio-panel/models', requireStaff, async (req, res) => {
    try {
      // Detect optional tables (your project may or may not have these)
      const hasProfiles = await tableExists('model_profiles');
      const hasDocs = (await tableExists('documents')) || (await tableExists('model_documents'));
      const hasPhotos = (await tableExists('photos')) || (await tableExists('model_photos'));
      const hasReleases = await tableExists('master_releases');
      const hasPolicies = await tableExists('model_policies');
      const hasW9 = (await tableExists('w9_uploads')) || (await tableExists('model_w9'));

      // Build base query
      // Always pull from users. Join optional profile table if it exists.
      let rows = [];
      if (hasProfiles) {
        rows = await dbAll(
          `
          SELECT
            u.id,
            u.username,
            u.status,
            p.preferred_name,
            p.legal_name,
            p.date_of_birth,
            p.headshot_path
          FROM users u
          LEFT JOIN model_profiles p ON p.user_id = u.id
          WHERE u.role = 'model'
          ORDER BY
            CASE u.status
              WHEN 'pending' THEN 0
              WHEN 'approved' THEN 1
              WHEN 'active' THEN 2
              WHEN 'disabled' THEN 9
              ELSE 5
            END,
            u.id DESC
        `
        );
      } else {
        rows = await dbAll(
          `
          SELECT id, username, status
          FROM users
          WHERE role='model'
          ORDER BY
            CASE status
              WHEN 'pending' THEN 0
              WHEN 'approved' THEN 1
              WHEN 'active' THEN 2
              WHEN 'disabled' THEN 9
              ELSE 5
            END,
            id DESC
        `
        );
      }

      // Enrich each model with counts/status fields your EJS expects
      const models = [];
      for (const r of rows) {
        const id = r.id;

        // Docs count (best-effort across likely table names/columns)
        let docs_count = 0;
        if (hasDocs) {
          // Try a few likely schemas
          docs_count =
            (await safeCount(`SELECT COUNT(*) AS c FROM documents WHERE user_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM documents WHERE model_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM model_documents WHERE user_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM model_documents WHERE model_id = ?`, [id]));
        }

        // Photos count + headshot path (if not already from profile)
        let photos_count = 0;
        if (hasPhotos) {
          photos_count =
            (await safeCount(`SELECT COUNT(*) AS c FROM photos WHERE user_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM photos WHERE model_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM model_photos WHERE user_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM model_photos WHERE model_id = ?`, [id]));
        }

        // Release status (simple boolean-ish)
        let release_status = null;
        if (hasReleases) {
          const rel =
            (await dbGet(
              `SELECT status, signed_at FROM master_releases WHERE user_id = ? ORDER BY id DESC LIMIT 1`,
              [id]
            )) ||
            (await dbGet(
              `SELECT status, signed_at FROM master_releases WHERE model_id = ? ORDER BY id DESC LIMIT 1`,
              [id]
            ));
          if (rel) release_status = rel.signed_at ? 'Signed' : (rel.status || 'Not signed');
        }

        // Consent/policies status
        let consent_status = null;
        if (hasPolicies) {
          const pol =
            (await dbGet(
              `SELECT updated_at FROM model_policies WHERE user_id = ? ORDER BY id DESC LIMIT 1`,
              [id]
            )) ||
            (await dbGet(
              `SELECT updated_at FROM model_policies WHERE model_id = ? ORDER BY id DESC LIMIT 1`,
              [id]
            ));
          if (pol) consent_status = pol.updated_at ? 'Saved' : 'Not completed';
        }

        // W9 status
        let w9_status = null;
        if (hasW9) {
          const w =
            (await safeCount(`SELECT COUNT(*) AS c FROM w9_uploads WHERE user_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM w9_uploads WHERE model_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM model_w9 WHERE user_id = ?`, [id])) ||
            (await safeCount(`SELECT COUNT(*) AS c FROM model_w9 WHERE model_id = ?`, [id]));
          if (w > 0) w9_status = 'Uploaded';
        }

        models.push({
          id,
          username: r.username,
          status: r.status || 'pending',
          preferred_name: firstOf(r, ['preferred_name'], null),
          legal_name: firstOf(r, ['legal_name'], null),
          date_of_birth: firstOf(r, ['date_of_birth', 'dob'], null),
          headshot_path: firstOf(r, ['headshot_path'], null),

          docs_count,
          photos_count,

          release_status: release_status || 'Not signed',
          consent_status: consent_status || 'Not completed',
          w9_status: w9_status || 'None',
        });
      }

      return res.render('studio-models', { models });
    } catch (err) {
      console.error('Studio models page error:', err);
      return res.status(500).render('error', { message: 'An internal error occurred.' });
    }
  });

  // ------------------------
  // Update Model Status
  // POST /studio-panel/models/:id/status
  // ------------------------
  router.post('/studio-panel/models/:id/status', requireStaff, async (req, res) => {
    try {
      const id = parseInt(req.params.id, 10);
      const status = String(req.body?.status || '').trim().toLowerCase();

      const allowed = new Set(['pending', 'approved', 'active', 'disabled']);
      if (!Number.isFinite(id) || !allowed.has(status)) {
        return res.status(400).render('error', { message: 'Invalid request.' });
      }

      await dbRun(`UPDATE users SET status = ? WHERE id = ? AND role = 'model'`, [status, id]);

      ctx.audit?.log?.(req, 'model_status_update', `Model user_id=${id} status=${status}`);

      // Return to models list
      return res.redirect('/studio-panel/models');
    } catch (err) {
      console.error('Update model status error:', err);
      return res.status(500).render('error', { message: 'An internal error occurred.' });
    }
  });

  // ------------------------
  // Inspect Model
  // GET /studio-panel/models/:id
  // Renders studio-model-view.ejs if it exists, otherwise a safe fallback.
  // ------------------------
  router.get('/studio-panel/models/:id', requireStaff, async (req, res) => {
    try {
      const id = parseInt(req.params.id, 10);
      if (!Number.isFinite(id)) {
        return res.status(400).render('error', { message: 'Invalid model id.' });
      }

      // minimal model fetch
      const model = await dbGet(
        `SELECT id, username, status FROM users WHERE id = ? AND role = 'model' LIMIT 1`,
        [id]
      );

      if (!model) {
        return res.status(404).render('error', { message: 'Model not found.' });
      }

      // If you have a specific inspect view, we render it.
      // Your tree shows: views/studio-model-view.ejs and/or studio-model-detail.ejs
      // Start with studio-model-view.
      return res.render('studio-model-view', { model });
    } catch (err) {
      console.error('Inspect model error:', err);
      return res.status(500).render('error', { message: 'An internal error occurred.' });
    }
  });

  return router;
};
